<!DOCTYPE html>
<html>
<head>
<title>concurrency_bangla.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h2 id="%E0%A6%AA%E0%A6%BE%E0%A6%B0%E0%A6%AB%E0%A6%B0%E0%A6%AE%E0%A7%8D%E0%A6%AF%E0%A6%BE%E0%A6%A8%E0%A7%8D%E0%A6%B8-%E0%A6%86%E0%A6%A8%E0%A6%B2%E0%A6%95-%E0%A6%95%E0%A6%B0%E0%A6%BE-dart-%E0%A6%8F-%E0%A6%95%E0%A6%A8%E0%A6%95%E0%A6%BE%E0%A6%B0%E0%A7%87%E0%A6%A8%E0%A7%8D%E0%A6%B8%E0%A6%BF-%E0%A6%8F%E0%A6%AC%E0%A6%82-%E0%A6%AA%E0%A7%8D%E0%A6%AF%E0%A6%BE%E0%A6%B0%E0%A6%BE%E0%A6%B2%E0%A6%BE%E0%A6%B2%E0%A6%BF%E0%A6%9C%E0%A6%AE">পারফরম্যান্স আনলক করা: Dart-এ কনকারেন্সি এবং প্যারালালিজম</h2>
<p>এতক্ষণে আপনারা হয়তো থ্রেড (thread) সম্পর্কে শুনেছেন এবং কীভাবে এটি অ্যাপকে একই সাথে একাধিক কাজ করতে সাহায্য করে, সবকিছু মসৃণ রাখে। Dart-এর ক্ষেত্রে ব্যাপারগুলো একটু ভিন্ন। যদিও আমরা অন্যান্য ভাষার মতো প্রথাগত থ্রেড নিয়ে তেমন একটা কাজ করি না, Dart কনকারেন্সি (concurrency) (একাধিক কাজ একই মাইক্রোসেকেন্ডে না করেও সেগুলোর অগ্রগতি করা) এবং প্যারালালিজম (parallelism) (প্রসেসরের বিভিন্ন কোরে একই সাথে একাধিক কাজ করা) উভয়ের জন্যই শক্তিশালী ম্যাকানিজম সরবরাহ করে।</p>
<p>এই ধারণাগুলো <em>কী</em> বোঝায় তা আমরা ইতিমধ্যে আলোচনা করেছি। এখন, আসুন দেখি <em>কেন, কীভাবে এবং কখন</em> আপনি আপনার পিওর Dart অ্যাপ্লিকেশনগুলোতে আরও প্রতিক্রিয়াশীল এবং পারফরম্যান্ট সফ্টওয়্যার তৈরি করতে এগুলো ব্যবহার করবেন।</p>
<h3 id="%E0%A6%95%E0%A7%87%E0%A6%A8-%E0%A6%8F%E0%A6%A4%E0%A6%95%E0%A6%BF%E0%A6%9B%E0%A7%81-%E0%A6%97%E0%A6%A4%E0%A6%BF-%E0%A6%8F%E0%A6%AC%E0%A6%82-%E0%A6%AA%E0%A7%8D%E0%A6%B0%E0%A6%A4%E0%A6%BF%E0%A6%95%E0%A7%8D%E0%A6%B0%E0%A6%BF%E0%A6%AF%E0%A6%BC%E0%A6%BE%E0%A6%B6%E0%A7%80%E0%A6%B2%E0%A6%A4%E0%A6%BE%E0%A6%B0-%E0%A6%AA%E0%A7%8D%E0%A6%B0%E0%A6%AF%E0%A6%BC%E0%A7%8B%E0%A6%9C%E0%A6%A8%E0%A7%80%E0%A6%AF%E0%A6%BC%E0%A6%A4%E0%A6%BE">কেন এতকিছু? গতি এবং প্রতিক্রিয়াশীলতার প্রয়োজনীয়তা</h3>
<p>ভাবুন আপনার Dart অ্যাপটিকে নেটওয়ার্ক থেকে ডেটা আনতে হবে, একটি বড় ফাইল পড়তে হবে বা সত্যিই জটিল কোনো গণনা করতে হবে। যদি আপনি এটি সরাসরি মেইন আইসোলেটে (main isolate) (যে একক থ্রেডে Dart অ্যাপ্লিকেশন শুরু হয়) করেন, আপনার পুরো অ্যাপ্লিকেশনটি জমে যাবে। কোনো ইউজার ইন্টারফেস (user interface) আপডেট হবে না, ক্লিকে কোনো সাড়া দেবে না – শুধু একটি হতাশাজনক বিরতি। এখানেই Dart-এর অ্যাসিঙ্ক্রোনাস (asynchronous) টুলগুলো কাজে আসে।</p>
<ul>
<li><strong>Concurrency (<code>async</code>/<code>await</code>)</strong> I/O-বাউন্ড অপারেশনের জন্য অসাধারণ। যেমন নেটওয়ার্ক রিকোয়েস্ট, ফাইল সিস্টেম অ্যাক্সেস বা টাইমারের জন্য অপেক্ষা করা। আপনার অ্যাপ একটি অপারেশন শুরু করতে পারে, তারপর সেটি সম্পন্ন হওয়ার জন্য অপেক্ষা করার সময় অন্য কিছু করতে পারে, যা UI-কে জমে যাওয়া থেকে রক্ষা করে। এটা অনেকটা একজন শেফের পানি গরম করতে (একটি I/O টাস্ক) দিয়ে তারপর সবজি কাটার মতো, যখন পানি গরম হচ্ছে। তারা একাধিক কাজ একই সময়ে করছে, কিন্তু দুটোই একই মুহূর্তে না-ও হতে পারে।</li>
<li><strong>Parallelism (Isolates)</strong> আপনার CPU-বাউন্ড অপারেশনের জন্য সেরা। এই কাজগুলো সত্যিই সংখ্যা নিয়ে কাজ করে এবং প্রসেসর দখল করে রাখে, যেমন বিশাল JSON ফাইল পার্স করা, জটিল ইমেজ প্রসেসিং বা ক্রিপ্টোগ্রাফিক ক্যালকুলেশন। Isolate-গুলো Dart-কে অন্যান্য প্রসেসর কোরে কোড এক্সিকিউট করতে দেয়, সত্যিকার অর্থে প্যারালালি, আপনার প্রধান অ্যাপ্লিকেশনের প্রতিক্রিয়াশীলতা ব্লক না করে। এটা অনেকটা রান্নাঘরে একাধিক শেফ থাকার মতো, প্রত্যেকে একই সাথে বিভিন্ন জটিল ডিশ তৈরি করছে।</li>
</ul>
<h3 id="dart-%E0%A6%95%E0%A7%80%E0%A6%AD%E0%A6%BE%E0%A6%AC%E0%A7%87-%E0%A6%8F%E0%A6%9F%E0%A6%BF-%E0%A6%95%E0%A6%B0%E0%A7%87-%E0%A6%87%E0%A6%AD%E0%A7%87%E0%A6%A8%E0%A7%8D%E0%A6%9F-%E0%A6%B2%E0%A7%81%E0%A6%AA-%E0%A6%8F%E0%A6%AC%E0%A6%82-%E0%A6%86%E0%A6%87%E0%A6%B8%E0%A7%8B%E0%A6%B2%E0%A7%87%E0%A6%9F-event-loop-and-isolates">Dart কীভাবে এটি করে: ইভেন্ট লুপ এবং আইসোলেট (Event Loop and Isolates)</h3>
<p>প্রতিটি আইসোলেটের মধ্যে Dart-এর প্রধান এক্সিকিউশন মডেলটি একক-থ্রেডেড, যা একটি <strong>ইভেন্ট লুপের (event loop)</strong> চারপাশে ঘোরে। যখন আপনি একটি আইসোলেটের মধ্যে <code>async</code> এবং <code>await</code> ব্যবহার করেন, তখন আপনি Dart-কে বলছেন, &quot;এই অপারেশনটিতে কিছুটা সময় লাগতে পারে। শুধু বসে থেকো না; অন্য ইভেন্টগুলো প্রসেস করো এবং এই <code>Future</code> সম্পন্ন হলে এখানে ফিরে এসো।&quot; এটি I/O টাস্কগুলোর জন্য দুর্দান্ত কারণ অপেক্ষার সময় CPU আসলে ব্যস্ত থাকে না; এটি শুধু নেটওয়ার্ক বা ডিস্ক থেকে ডেটা আসার জন্য অপেক্ষা করে।</p>
<p>কিন্তু যদি CPU নিজেই বটেলনেক (bottleneck) হয়? এখানেই <strong>Isolates</strong> কাজে আসে।</p>
<p>একটি Isolate হলো একটি স্বাধীন কর্মীর মতো যার নিজস্ব মেমরি এবং নিজস্ব ইভেন্ট লুপ রয়েছে। <strong>গুরুত্বপূর্ণভাবে, আইসোলেটগুলো আপনার প্রধান অ্যাপ্লিকেশনের আইসোলেটের (বা অন্য কোনো আইসোলেটের) সাথে মেমরি শেয়ার করে না।</strong> প্রতিটি আইসোলেটের নিজস্ব মেমরি হিপ (memory heap) থাকে, যা নিশ্চিত করে যে শেয়ার্ড ডেটার উপর কোনো রেস কন্ডিশন (race condition) নেই এবং প্রথাগত মাল্টিথ্রেডিং-এ পাওয়া জটিল লকিং ম্যাকানিজমের প্রয়োজনীয়তা এড়িয়ে যায়। এটি Dart-এর কনকারেন্সি মডেলের একটি মৌলিক দিক, যা নিরাপত্তা এবং সরলতার জন্য ডিজাইন করা হয়েছে।</p>
<h4 id="%E0%A6%86%E0%A6%87%E0%A6%B8%E0%A7%8B%E0%A6%B2%E0%A7%87%E0%A6%9F%E0%A6%97%E0%A7%81%E0%A6%B2%E0%A7%8B%E0%A6%B0-%E0%A6%AE%E0%A6%A7%E0%A7%8D%E0%A6%AF%E0%A7%87-%E0%A6%AF%E0%A7%8B%E0%A6%97%E0%A6%BE%E0%A6%AF%E0%A7%8B%E0%A6%97-%E0%A6%AE%E0%A7%87%E0%A6%B8%E0%A7%87%E0%A6%9C-%E0%A6%AA%E0%A6%BE%E0%A6%B8%E0%A6%BF%E0%A6%82-sendport-%E0%A6%8F%E0%A6%AC%E0%A6%82-receiveport">আইসোলেটগুলোর মধ্যে যোগাযোগ: মেসেজ পাসিং, <code>SendPort</code>, এবং <code>ReceivePort</code></h4>
<p>যেহেতু আইসোলেটগুলো মেমরি শেয়ার করে না, তাদের মধ্যে যোগাযোগ সম্পূর্ণভাবে <strong>মেসেজ পাসিংয়ের (passing messages)</strong> মাধ্যমে ঘটে। এটিকে বিভিন্ন অফিসের মধ্যে চিঠি বা পার্সেল আদান-প্রদানের মতো ভাবুন—এটি নিরাপদ, নিয়ন্ত্রিত এবং অ্যাসিঙ্ক্রোনাস।</p>
<p><strong>মেসেজ পাসিং আসলে কীভাবে কাজ করে:</strong>
যখন একটি আইসোলেট অন্যটিতে একটি মেসেজ পাঠায়, তখন Dart রানটাইম কার্যকরভাবে মেসেজটি কপি করে (বা নির্দিষ্ট ধরণের ডেটার মালিকানা স্থানান্তর করে) প্রেরকের মেমরি হিপ থেকে প্রাপকের মেমরি হিপে। এটি নিশ্চিত করে যে আইসোলেশন বজায় থাকে। গ্রহণকারী আইসোলেট তারপর তার ইভেন্ট লুপের মাধ্যমে এই মেসেজটি প্রসেস করে।</p>
<p>এই প্রক্রিয়াটি <code>SendPort</code> এবং <code>ReceivePort</code> অবজেক্ট দ্বারা সহজতর হয়:</p>
<ul>
<li><code>ReceivePort</code>: একটি আইসোলেট আগত মেসেজ শোনার জন্য একটি <code>ReceivePort</code> তৈরি করে। এটি একটি <code>Stream</code> এক্সপোজ করে যা মেসেজ আসার সাথে সাথে তা নির্গত করে। একটি <code>ReceivePort</code>-এর একটি সংশ্লিষ্ট <code>SendPort</code> থাকে।</li>
<li><code>SendPort</code>: <code>SendPort</code> হলো তার <code>ReceivePort</code>-এর জন্য মেইলিং ঠিকানার মতো। আপনি অন্য আইসোলেটে একটি <code>SendPort</code> পাস করতে পারেন, যার ফলে সেই আইসোলেটটি তার সাথে যুক্ত <code>ReceivePort</code>-এ মেসেজ ফেরত পাঠাতে পারে।</li>
</ul>
<p><strong><code>SendPort</code> এবং <code>ReceivePort</code>-এর দৃশ্যায়ন:</strong></p>
<p>দুটি আইসোলেট কল্পনা করুন, Isolate A (Main) এবং Isolate B (Worker):</p>
<img src="file:///Users/muntasirmahmudsaif/Desktop/isolates.png" alt="isolated" width="350">
<p>১.  <strong>সেটআপ (Setup)</strong>:
* Isolate A তৈরি করে <code>rpA = ReceivePort()</code> এবং এর <code>spA = rpA.sendPort</code> পায়।
* Isolate A যখন Isolate B স্পন (spawn) করে, তখন এটি প্রাথমিক মেসেজের অংশ হিসাবে <code>spA</code> কে Isolate B-তে পাস করতে পারে।
* Isolate B যদি সরাসরি A থেকে (শুধু প্রাথমিক সেটআপ মেসেজ ছাড়াও) বা অন্যান্য আইসোলেট থেকে মেসেজ গ্রহণ করতে চায়, তাহলে এটি নিজস্ব <code>rpB</code> এবং <code>spB</code> তৈরি করতে পারে। সাধারণ রিকোয়েস্ট-রেসপন্সের জন্য, Isolate A তার <code>spA</code> কে Isolate B-তে পাস করতে পারে এবং Isolate B ফলাফল ফেরত পাঠানোর জন্য এই <code>spA</code> ব্যবহার করে।</p>
<p>২.  <strong>মেসেজ পাঠানো (Sending a Message)</strong>:
* Isolate A, Isolate B-তে ডেটা পাঠাতে চায়। এটি একটি <code>SendPort</code> ব্যবহার করে যা Isolate B এক্সপোজ করেছে (যেমন, <code>workerSendPort</code> যা B স্পন করার সময় প্রাপ্ত হয়েছিল বা B থেকে ফেরত পাঠানো হয়েছিল)।
* <code>workerSendPort.send(messageData);</code></p>
<p>৩.  <strong>মেসেজ গ্রহণ করা (Receiving a Message)</strong>:
* Isolate B-এর <code>ReceivePort</code> (<code>rpB</code>) তার স্ট্রিমের মাধ্যমে <code>messageData</code> নির্গত করবে।
* Isolate B এই স্ট্রীমটি শোনে: <code>rpB.listen((dynamic message) { /* process message */ });</code></p>
<p><strong>কী ধরনের ডেটা পাঠানো যায়?</strong>
মেসেজগুলো সাধারণত কপি করা হয়, তাই ডেটা অবশ্যই &quot;প্রেরণযোগ্য&quot; (sendable) হতে হবে। এর মধ্যে রয়েছে:</p>
<ul>
<li>প্রিমিটিভ টাইপ (Primitive types): <code>null</code>, <code>bool</code>, <code>int</code>, <code>double</code>, <code>String</code>।</li>
<li><code>SendPort</code> এবং <code>Capability</code>-এর ইনস্ট্যান্স।</li>
<li>List এবং Map যার উপাদানগুলো নিজেরাই প্রেরণযোগ্য টাইপ।</li>
<li>কিছু বিশেষ অবজেক্ট যা কপি না করে দক্ষতার সাথে স্থানান্তর করা যায়, যেমন <code>Uint8List</code> (transferable objects)।</li>
</ul>
<p><strong>সীমাবদ্ধতা (Limitations):</strong></p>
<ul>
<li><strong>জটিল অবজেক্ট (Complex Objects)</strong>: নির্বিচারে ক্লাসের ইনস্ট্যান্স যা সম্পূর্ণরূপে প্রেরণযোগ্য টাইপ দ্বারা গঠিত নয়, সেগুলো সরাসরি প্রেরণযোগ্য নাও হতে পারে যদি সেগুলোতে উদাহরণস্বরূপ, নেটিভ রিসোর্স বা অন্যান্য অ-স্থানান্তরযোগ্য স্টেট থাকে। আপনাকে সাধারণত সেগুলোকে একটি প্রেরণযোগ্য ফরম্যাটে (যেমন, JSON) সিরিয়ালাইজ করতে হবে এবং তারপরে গ্রহণকারী আইসোলেটে ডিসিরিয়ালাইজ করতে হবে।</li>
<li><strong>ক্লোজার (Closures - Anonymous Functions)</strong>: আপনি সরাসরি নির্বিচারে ক্লোজার মেসেজ হিসাবে পাঠাতে পারবেন না। <code>Isolate.spawn()</code> বা <code>compute()</code>-তে পাস করা ফাংশনগুলো অবশ্যই টপ-লেভেল ফাংশন বা স্ট্যাটিক মেথড হতে হবে। এর কারণ হলো একটি ক্লোজার তার চারপাশের লেক্সিক্যাল স্কোপ (পরিবেশ থেকে ভেরিয়েবল যেখানে এটি তৈরি হয়েছিল) ক্যাপচার করতে পারে এবং সেই স্কোপ নতুন আইসোলেটের মেমরিতে বিদ্যমান নেই।</li>
</ul>
<h4 id="%E0%A6%86%E0%A6%87%E0%A6%B8%E0%A7%8B%E0%A6%B2%E0%A7%87%E0%A6%9F-%E0%A6%B8%E0%A7%8D%E0%A6%AA%E0%A6%A8-%E0%A6%95%E0%A6%B0%E0%A6%BE-isolatespawn-%E0%A6%A6%E0%A6%BF%E0%A6%AF%E0%A6%BC%E0%A7%87-%E0%A6%AE%E0%A7%8D%E0%A6%AF%E0%A6%BE%E0%A6%A8%E0%A7%81%E0%A6%AF%E0%A6%BC%E0%A6%BE%E0%A6%B2-%E0%A6%A8%E0%A6%BF%E0%A6%AF%E0%A6%BC%E0%A6%A8%E0%A7%8D%E0%A6%A4%E0%A7%8D%E0%A6%B0%E0%A6%A3-%E0%A6%8F%E0%A6%AC%E0%A6%82-%E0%A6%8F%E0%A6%95%E0%A6%9F%E0%A6%BF-%E0%A6%B8%E0%A6%B9%E0%A6%BE%E0%A6%AF%E0%A6%BC%E0%A6%95-compute">আইসোলেট স্পন করা: <code>Isolate.spawn()</code> দিয়ে ম্যানুয়াল নিয়ন্ত্রণ এবং একটি সহায়ক: <code>compute()</code></h4>
<p>আপনি <code>Isolate.spawn()</code> ব্যবহার করে ম্যানুয়ালি আইসোলেট স্পন করতে পারেন, যা আপনাকে <code>ReceivePort</code> এবং <code>SendPort</code> এর সাথে দ্বিমুখী যোগাযোগ স্থাপনের উপর সূক্ষ্ম নিয়ন্ত্রণ দেয়।</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> <span class="hljs-string">'dart:isolate'</span>;

<span class="hljs-comment">// নতুন আইসোলেটের জন্য এন্ট্রি পয়েন্ট</span>
<span class="hljs-keyword">void</span> _newIsolateEntry(SendPort mainSendPort) {
  ReceivePort newIsolateReceivePort = ReceivePort();
  mainSendPort.send(newIsolateReceivePort.sendPort); <span class="hljs-comment">// এর SendPort প্রধান আইসোলেটে পাঠান</span>

  newIsolateReceivePort.listen((<span class="hljs-built_in">dynamic</span> message) {
    <span class="hljs-keyword">if</span> (message <span class="hljs-keyword">is</span> <span class="hljs-built_in">String</span>) {
      <span class="hljs-built_in">print</span>(<span class="hljs-string">'New Isolate received: <span class="hljs-subst">$message</span>'</span>);
      <span class="hljs-keyword">final</span> result = message.toUpperCase() + <span class="hljs-string">" (processed by isolate)"</span>;
      mainSendPort.send(result);
    }
  });
}

<span class="hljs-comment">// প্রধান আইসোলেটে</span>
Future&lt;<span class="hljs-keyword">void</span>&gt; useManualSpawn() <span class="hljs-keyword">async</span> {
  ReceivePort mainReceivePort = ReceivePort();

  <span class="hljs-built_in">print</span>(<span class="hljs-string">'Main Isolate: Spawning new isolate.'</span>);
  Isolate newIsolate = <span class="hljs-keyword">await</span> Isolate.spawn(_newIsolateEntry, mainReceivePort.sendPort);

  SendPort? newIsolateSendPort;
  Completer&lt;<span class="hljs-keyword">void</span>&gt; isolateReadyCompleter = Completer();

  mainReceivePort.listen((<span class="hljs-built_in">dynamic</span> message) {
    <span class="hljs-keyword">if</span> (message <span class="hljs-keyword">is</span> SendPort) {
      newIsolateSendPort = message;
      <span class="hljs-built_in">print</span>(<span class="hljs-string">'Main Isolate: Received SendPort from new isolate.'</span>);
      newIsolateSendPort?.send(<span class="hljs-string">'Hello from Main Isolate!'</span>);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (message <span class="hljs-keyword">is</span> <span class="hljs-built_in">String</span>) {
      <span class="hljs-built_in">print</span>(<span class="hljs-string">'Main Isolate: Received result: <span class="hljs-subst">$message</span>'</span>);
      mainReceivePort.close(); <span class="hljs-comment">// কাজ শেষে পোর্ট বন্ধ করুন</span>
      newIsolate.kill(priority: Isolate.immediate); <span class="hljs-comment">// আইসোলেট পরিষ্কার করুন</span>
      <span class="hljs-keyword">if</span> (!isolateReadyCompleter.isCompleted) {
        isolateReadyCompleter.complete();
      }
    }
  });
  <span class="hljs-keyword">await</span> isolateReadyCompleter.future; <span class="hljs-comment">// কমিউনিকেশন চক্র সম্পন্ন হওয়ার জন্য অপেক্ষা করুন</span>
  <span class="hljs-built_in">print</span>(<span class="hljs-string">'Main Isolate: Manual spawn example finished.'</span>);
}
</div></code></pre>
<p>তবে, অনেক সাধারণ ব্যবহারের ক্ষেত্রে, <strong>Flutter framework</strong> একটি সহজ উচ্চ-স্তরের ফাংশন সরবরাহ করে: <code>compute()</code>।
<em>(স্পষ্টীকরণ: <code>compute()</code> <code>flutter/foundation.dart</code> লাইব্রেরির অংশ এবং এটি Flutter অ্যাপ্লিকেশনগুলোর মধ্যে নির্বিঘ্নে কাজ করার জন্য ডিজাইন করা হয়েছে। Flutter ব্যবহার না করা পিওর Dart অ্যাপ্লিকেশনগুলোর জন্য, আপনি সাধারণত সরাসরি <code>Isolate.spawn()</code> ব্যবহার করবেন বা অনুরূপ কোনো সহায়ক প্রয়োগ করবেন।)</em></p>
<p>আপনি যদি একটি Flutter পরিবেশে থাকেন, <code>compute()</code> একটি নতুন আইসোলেটে একটি ফাংশন চালানো সহজ করে তোলে:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// একটি Flutter অ্যাপে ( নিশ্চিত করুন যে আপনি flutter/foundation.dart ইম্পোর্ট করেছেন)</span>
<span class="hljs-comment">// import 'package:flutter/foundation.dart';</span>

<span class="hljs-comment">// এই ফাংশনটি একটি পৃথক আইসোলেটে কার্যকর হবে।</span>
<span class="hljs-comment">// এটি অবশ্যই একটি টপ-লেভেল ফাংশন বা একটি স্ট্যাটিক মেথড হতে হবে।</span>
<span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">dynamic</span>&gt; _parseJsonInIsolate(<span class="hljs-built_in">String</span> jsonData) {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Parsing JSON in a separate isolate..."</span>);
  <span class="hljs-comment">// কিছু ভারী পার্সিং কাজের অনুকরণ করুন</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000000</span>; i++) {
    <span class="hljs-comment">// শুধু কাজ অনুকরণ করার জন্য একটি ব্যস্ত লুপ</span>
  }
  <span class="hljs-comment">// একটি বাস্তব পরিস্থিতিতে, আপনি dart:convert ব্যবহার করতেন</span>
  <span class="hljs-comment">// final Map&lt;String, dynamic&gt; data = jsonDecode(jsonData);</span>
  <span class="hljs-keyword">final</span> <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">dynamic</span>&gt; data = {<span class="hljs-string">"message"</span>: <span class="hljs-string">"Parsed: <span class="hljs-subst">$jsonData</span>"</span>}; <span class="hljs-comment">// সরলীকৃত</span>
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Parsing complete in isolate."</span>);
  <span class="hljs-keyword">return</span> data;
}

<span class="hljs-comment">// আপনার Flutter উইজেট বা সার্ভিসে:</span>
<span class="hljs-comment">// await compute(_parseJsonInIsolate, massiveJsonString);</span>
</div></code></pre>
<p><strong><code>Isolate.spawn()</code> বা <code>compute()</code>-তে পাস করা ফাংশন সম্পর্কে মূল বিষয়গুলো:</strong></p>
<ul>
<li>এগুলো অবশ্যই <strong>টপ-লেভেল ফাংশন বা স্ট্যাটিক মেথড</strong> হতে হবে। ইনস্ট্যান্স মেথড বা ক্লোজার যা <code>this</code> বা লোকাল ভেরিয়েবল ক্যাপচার করে সেগুলো সরাসরি নতুন আইসোলেটের এন্ট্রি পয়েন্ট হিসাবে ব্যবহার করা যাবে না।</li>
</ul>
<h3 id="%E0%A6%93%E0%A6%AD%E0%A6%BE%E0%A6%B0%E0%A6%B9%E0%A7%87%E0%A6%A1-%E0%A6%8F%E0%A6%AC%E0%A6%82-%E0%A6%95%E0%A6%96%E0%A6%A8-%E0%A6%86%E0%A6%87%E0%A6%B8%E0%A7%8B%E0%A6%B2%E0%A7%87%E0%A6%9F-%E0%A6%AC%E0%A7%8D%E0%A6%AF%E0%A6%AC%E0%A6%B9%E0%A6%BE%E0%A6%B0-%E0%A6%95%E0%A6%B0%E0%A6%AC%E0%A7%87%E0%A6%A8-overhead-and-when-to-use-isolates">ওভারহেড এবং কখন আইসোলেট ব্যবহার করবেন (Overhead and When to Use Isolates)</h3>
<p>একটি আইসোলেট স্পন করা বিনামূল্যে নয়। এর মধ্যে রয়েছে:</p>
<ul>
<li>নতুন আইসোলেটের জন্য একটি পৃথক মেমরি হিপ বরাদ্দ করা।</li>
<li>সেই আইসোলেটের জন্য একটি নতুন ইভেন্ট লুপ শুরু করা।</li>
<li>আইসোলেটগুলোর মধ্যে মেসেজ পাসিংয়ের খরচ (ডেটা কপি করা)।</li>
</ul>
<p><strong>কখন এগুলো ব্যবহার করা সার্থক?</strong></p>
<ul>
<li><strong>সত্যিকারের ভারী CPU-বাউন্ড কাজ</strong>: যদি একটি টাস্কে উল্লেখযোগ্য গণনা জড়িত থাকে যা শত শত মিলিসেকেন্ড বা এমনকি সেকেন্ড সময় নিতে পারে, প্রধান আইসোলেট ব্লক করে এবং UI জ্যাঙ্ক বা প্রতিক্রিয়াহীনতার কারণ হয়, তবে এটিকে অন্য আইসোলেটে অফলোড করা উপকারী। উদাহরণস্বরূপ জটিল ডেটা প্রসেসিং, ক্রিপ্টোগ্রাফি বা নিবিড় গণনা।</li>
<li><strong>ছোট কাজের জন্য খরচ সুবিধার চেয়ে বেশি</strong>: খুব সংক্ষিপ্ত গণনার জন্য (যেমন, কয়েক মিলিসেকেন্ড), একটি আইসোলেট তৈরি এবং মেসেজ পাস করার ওভারহেড প্যারালাল এক্সিকিউশনের মাধ্যমে সাশ্রয় হওয়া সময়ের চেয়ে বেশি হতে পারে। এই ধরনের ক্ষেত্রে, প্রধান আইসোলেটে কাজটি করা (যদি এটি প্রতিক্রিয়াশীলতাকে প্রভাবিত না করে) বা অ্যালগরিদম অপ্টিমাইজ করা ভাল হতে পারে।</li>
<li><strong>I/O-এর জন্য <code>async</code>/<code>await</code> ব্যবহার করুন</strong>: I/O-বাউন্ড অপারেশনের জন্য (নেটওয়ার্ক রিকোয়েস্ট, ফাইল অ্যাক্সেস), যেখানে প্রোগ্রাম তার বেশিরভাগ সময় <em>অপেক্ষা</em> করে কাটায়, প্রধান আইসোলেটে <code>async</code>/<code>await</code> সাধারণত যথেষ্ট এবং নতুন আইসোলেট স্পন করার চেয়ে বেশি হালকা। একটি আইসোলেট একটি I/O অপারেশন দ্রুত সম্পন্ন করবে না যদি বটেলনেক বাহ্যিক সিস্টেম বা নেটওয়ার্ক হয়।</li>
</ul>
<p><strong>সংক্ষেপে: ওভারহেডকে ন্যায্যতা দেওয়ার জন্য যথেষ্ট কম্পিউটেশনালি নিবিড় কাজগুলোর জন্য বিচক্ষণতার সাথে আইসোলেট ব্যবহার করুন।</strong></p>
<h3 id="%E0%A6%86%E0%A6%87%E0%A6%B8%E0%A7%8B%E0%A6%B2%E0%A7%87%E0%A6%9F%E0%A6%B8-%E0%A6%95%E0%A6%A8%E0%A6%95%E0%A6%BE%E0%A6%B0%E0%A7%87%E0%A6%A8%E0%A7%8D%E0%A6%B8%E0%A6%BF-%E0%A6%A8%E0%A6%BE-%E0%A6%AA%E0%A7%8D%E0%A6%AF%E0%A6%BE%E0%A6%B0%E0%A6%BE%E0%A6%B2%E0%A6%BE%E0%A6%B2%E0%A6%BF%E0%A6%9C%E0%A6%AE-isolates-concurrency-or-parallelism">আইসোলেটস: কনকারেন্সি না প্যারালালিজম? (Isolates: Concurrency or Parallelism?)</h3>
<p>এটি একটি দারুণ প্রশ্ন! Dart-এর আইসোলেটগুলো <strong>কনকারেন্সি এবং সত্যিকারের প্যারালালিজম উভয়ই</strong> অর্জন করতে পারে।</p>
<ul>
<li><strong>কনকারেন্সি (Concurrency)</strong>: এমনকি একটি সিঙ্গেল-কোর প্রসেসরেও আপনার একাধিক আইসোলেট থাকতে পারে। যদিও সেই সিঙ্গেল কোরে যেকোনো একটি মাইক্রোসেকেন্ডে শুধুমাত্র একটি আইসোলেট চলতে পারে, অপারেটিং সিস্টেম তাদের মধ্যে স্যুইচ করতে পারে, যার ফলে তারা তাদের কাজগুলোতে <em>কনকারেন্টলি</em> অগ্রগতি করতে পারে। প্রধান আইসোলেট প্রতিক্রিয়াশীল থাকতে পারে যখন অন্য একটি আইসোলেট পটভূমিতে কাজ করে।</li>
<li><strong>প্যারালালিজম (Parallelism)</strong>: যদি আপনার ডিভাইসে একাধিক CPU কোর থাকে, Dart বিভিন্ন কোরে একই সাথে বিভিন্ন আইসোলেট চালাতে পারে (এবং সাধারণত চালায়)। এটি <strong>সত্যিকারের প্যারালালিজম</strong>, যেখানে একাধিক কোড লাইন একই সময়ে এক্সিকিউট হচ্ছে।</li>
</ul>
<p>সুতরাং, আইসোলেটগুলো ডিফল্টরূপে কনকারেন্সির জন্য একটি ম্যাকানিজম সরবরাহ করে (স্বাধীন অগ্রগতির অনুমতি দেয়), এবং হার্ডওয়্যার রিসোর্স (একাধিক কোর) উপলব্ধ থাকলে তারা প্যারালালিজম সক্ষম করে। CPU-বাউন্ড কাজের জন্য আইসোলেট ব্যবহারের প্রাথমিক লক্ষ্য হলো এই প্যারালালিজম অর্জন করা এবং প্রধান আইসোলেট (প্রায়শই UI-এর জন্য দায়ী) জমে যাওয়া থেকে রোধ করা।</p>
<h3 id="%E0%A6%AC%E0%A6%BE%E0%A6%B8%E0%A7%8D%E0%A6%A4%E0%A6%AC-%E0%A6%9C%E0%A7%80%E0%A6%AC%E0%A6%A8%E0%A7%87%E0%A6%B0-%E0%A6%AC%E0%A7%8D%E0%A6%AF%E0%A6%AC%E0%A6%B9%E0%A6%BE%E0%A6%B0-%E0%A6%8F%E0%A6%95%E0%A6%9F%E0%A6%BF-%E0%A6%B8%E0%A6%BE%E0%A6%B0%E0%A7%8D%E0%A6%AD%E0%A6%BE%E0%A6%B0-%E0%A6%85%E0%A7%8D%E0%A6%AF%E0%A6%BE%E0%A6%AA%E0%A7%8D%E0%A6%B2%E0%A6%BF%E0%A6%95%E0%A7%87%E0%A6%B6%E0%A6%A8%E0%A7%87%E0%A6%B0-%E0%A6%9C%E0%A6%A8%E0%A7%8D%E0%A6%AF-%E0%A6%AC%E0%A7%8D%E0%A6%AF%E0%A6%BE%E0%A6%95%E0%A6%97%E0%A7%8D%E0%A6%B0%E0%A6%BE%E0%A6%89%E0%A6%A8%E0%A7%8D%E0%A6%A1-%E0%A6%A1%E0%A7%87%E0%A6%9F%E0%A6%BE-%E0%A6%AA%E0%A7%8D%E0%A6%B0%E0%A6%B8%E0%A7%87%E0%A6%B8%E0%A6%BF%E0%A6%82">বাস্তব জীবনের ব্যবহার: একটি সার্ভার অ্যাপ্লিকেশনের জন্য ব্যাকগ্রাউন্ড ডেটা প্রসেসিং</h3>
<p><em>(আপনার মূল ডকুমেন্ট থেকে এই বিভাগটি মূলত প্রাসঙ্গিক, তবে নিশ্চিত করুন যে <code>Isolate.compute</code>কে Flutter-নির্দিষ্ট হিসাবে স্পষ্ট করা হয়েছে বা একটি পিওর Dart উদাহরণের জন্য <code>Isolate.spawn</code> ব্যবহার করুন।)</em></p>
<p>একটি পিওর Dart সার্ভার অ্যাপ্লিকেশন বিবেচনা করা যাক। যদি এটিকে বড় লগ ফাইল প্রসেস করতে হয়:</p>
<p><strong>আইসোলেট দিয়ে সমাধান (পিওর Dart-এর জন্য <code>Isolate.spawn</code> ব্যবহার করে):</strong></p>
<p>১. মেইন আইসোলেট একটি রিকোয়েস্ট গ্রহণ করে।
২. এটি <code>Isolate.spawn()</code> ব্যবহার করে প্রসেসিংকে একটি নতুন আইসোলেটে পাঠায়। ফলাফল ফেরত পাওয়ার জন্য এটির <code>ReceivePort</code> সেট আপ করতে হবে।
৩. নতুন আইসোলেট ফাইলটি প্রসেস করে (CPU-intensive)। এটি উপলব্ধ থাকলে একটি ভিন্ন কোরে ঘটে।
৪. মেইন আইসোলেট অন্যান্য রিকোয়েস্টের প্রতি প্রতিক্রিয়াশীল থাকে।
৫. ওয়ার্কার আইসোলেট তার প্রাপ্ত <code>SendPort</code>-এর মাধ্যমে ফলাফলটি মেইন আইসোলেটে ফেরত পাঠায়।
৬. মেইন আইসোলেট ফলাফলটি পরিচালনা করে।</p>
<p><strong>ধারণাগত কোড স্নিপেট (পিওর Dart সাথে <code>Isolate.spawn</code>):</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> <span class="hljs-string">'dart:isolate'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'dart:io'</span>; <span class="hljs-comment">// ফাইল অপারেশনের জন্য</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">'dart:async'</span>; <span class="hljs-comment">// Completer-এর জন্য</span>

<span class="hljs-comment">// এই ফাংশনটি নতুন আইসোলেটে চলে</span>
Future&lt;<span class="hljs-keyword">void</span>&gt; _processLogFileIsolateEntry(<span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">dynamic</span>&gt; message) <span class="hljs-keyword">async</span> {
  SendPort replyPort = message[<span class="hljs-string">'replyPort'</span>] <span class="hljs-keyword">as</span> SendPort;
  <span class="hljs-built_in">String</span> filePath = message[<span class="hljs-string">'filePath'</span>] <span class="hljs-keyword">as</span> <span class="hljs-built_in">String</span>;

  <span class="hljs-built_in">print</span>(<span class="hljs-string">"[Isolate <span class="hljs-subst">${Isolate.current.debugName}</span>] Processing log file: <span class="hljs-subst">$filePath</span>"</span>);
  <span class="hljs-built_in">String</span> report = <span class="hljs-string">"Report for <span class="hljs-subst">$filePath</span>:\n"</span>;
  <span class="hljs-keyword">try</span> {
    <span class="hljs-comment">// ফাইল পড়া এবং CPU-নিবিড় পার্সিং ও বিশ্লেষণের অনুকরণ</span>
    <span class="hljs-comment">// String fileContent = await File(filePath).readAsString(); // উদাহরণ: ফাইল পড়া</span>
    <span class="hljs-comment">// report += "Characters: ${fileContent.length}\n"; // উদাহরণ: বিশ্লেষণের অংশ</span>

    <span class="hljs-comment">// ভারী কাজের অনুকরণ</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2000000000</span>; i++){ <span class="hljs-comment">/* busy work */</span> }
    report += <span class="hljs-string">"Analysis complete. Found 5 critical errors.\n"</span>;
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"[Isolate <span class="hljs-subst">${Isolate.current.debugName}</span>] Finished processing <span class="hljs-subst">$filePath</span>"</span>);
    replyPort.send({<span class="hljs-string">'status'</span>: <span class="hljs-string">'success'</span>, <span class="hljs-string">'report'</span>: report});
  } <span class="hljs-keyword">catch</span> (e, s) {
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"[Isolate <span class="hljs-subst">${Isolate.current.debugName}</span>] Error processing <span class="hljs-subst">$filePath</span>: <span class="hljs-subst">$e</span>"</span>);
    replyPort.send({<span class="hljs-string">'status'</span>: <span class="hljs-string">'error'</span>, <span class="hljs-string">'error'</span>: e.toString(), <span class="hljs-string">'stackTrace'</span>: s.toString()});
  }
}

Future&lt;<span class="hljs-built_in">String</span>&gt; processLogFileWithIsolate(<span class="hljs-built_in">String</span> filePath) <span class="hljs-keyword">async</span> {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"[Main Isolate] Received request to process log file: <span class="hljs-subst">$filePath</span>"</span>);
  <span class="hljs-keyword">final</span> p = ReceivePort();
  <span class="hljs-keyword">final</span> completer = Completer&lt;<span class="hljs-built_in">String</span>&gt;();

  <span class="hljs-keyword">try</span> {
    <span class="hljs-comment">// আইসোলেট স্পন করুন</span>
    Isolate isolate = <span class="hljs-keyword">await</span> Isolate.spawn(
      _processLogFileIsolateEntry,
      {<span class="hljs-string">'replyPort'</span>: p.sendPort, <span class="hljs-string">'filePath'</span>: filePath},
      onError: p.sendPort, <span class="hljs-comment">// পোর্টে ত্রুটিও পাঠান</span>
      onExit: p.sendPort    <span class="hljs-comment">// প্রস্থান বার্তা পাঠান</span>
    );

    p.listen((<span class="hljs-built_in">dynamic</span> message) {
      <span class="hljs-keyword">if</span> (message <span class="hljs-keyword">is</span> <span class="hljs-built_in">Map</span> &amp;&amp; message[<span class="hljs-string">'status'</span>] == <span class="hljs-string">'success'</span>) {
        completer.complete(message[<span class="hljs-string">'report'</span>] <span class="hljs-keyword">as</span> <span class="hljs-built_in">String</span>);
        p.close();
        isolate.kill(priority: Isolate.immediate);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (message <span class="hljs-keyword">is</span> <span class="hljs-built_in">Map</span> &amp;&amp; message[<span class="hljs-string">'status'</span>] == <span class="hljs-string">'error'</span>) {
        completer.completeError(
          Exception(<span class="hljs-string">"Isolate error: <span class="hljs-subst">${message[<span class="hljs-string">'error'</span>]}</span>"</span>),
          StackTrace.fromString(message[<span class="hljs-string">'stackTrace'</span>] <span class="hljs-keyword">as</span> <span class="hljs-built_in">String</span>? ?? <span class="hljs-string">''</span>)
        );
        p.close();
        isolate.kill(priority: Isolate.immediate);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (message == <span class="hljs-keyword">null</span>) { <span class="hljs-comment">// onExit message</span>
        <span class="hljs-keyword">if</span> (!completer.isCompleted) {
            completer.completeError(Exception(<span class="hljs-string">"Isolate exited unexpectedly before sending a result."</span>));
        }
        p.close();
      }
    });
  } <span class="hljs-keyword">catch</span> (e,s) {
      completer.completeError(e,s);
      p.close();
  }
  <span class="hljs-keyword">return</span> completer.future;
}

<span class="hljs-comment">// উদাহরণ ব্যবহার:</span>
<span class="hljs-comment">// try {</span>
<span class="hljs-comment">//   String report = await processLogFileWithIsolate("path/to/user_uploaded_log.txt");</span>
<span class="hljs-comment">//   print("[Main Isolate] Log file processing complete. Report:\n$report");</span>
<span class="hljs-comment">// } catch (e) {</span>
<span class="hljs-comment">//   print("[Main Isolate] Error processing log file: $e");</span>
<span class="hljs-comment">// }</span>
</div></code></pre>
<h3 id="%E0%A6%89%E0%A6%AA%E0%A6%B8%E0%A6%82%E0%A6%B9%E0%A6%BE%E0%A6%B0-wrapping-up">উপসংহার (Wrapping Up)</h3>
<p>কখন এবং কীভাবে <code>async</code>/<code>await</code> এর সাথে কনকারেন্সি এবং Isolates এর সাথে প্যারালালিজম ব্যবহার করতে হয় তা বোঝা উচ্চ-পারফরম্যান্স, প্রতিক্রিয়াশীল Dart অ্যাপ্লিকেশন লেখার মূল চাবিকাঠি।</p>
<ul>
<li><code>async</code>/<code>await</code> আপনার অ্যাপকে অপেক্ষার সময় জমে যাওয়া থেকে রক্ষা করে, I/O-বাউন্ড কাজের জন্য আদর্শ।</li>
<li><strong>Isolates</strong> আপনাকে ভারী CPU-বাউন্ড কাজের জন্য মাল্টি-কোর প্রসেসরের সম্পূর্ণ শক্তি ব্যবহার করতে দেয়, সত্যিকারের প্যারালালিজম অর্জন করে।
<ul>
<li>তারা পৃথক মেমরি হিপের কারণে <strong>স্পনিং আইসোলেট থেকে ভেরিয়েবল অ্যাক্সেস করতে পারে না</strong>।</li>
<li><code>Isolate.spawn()</code> (বা Flutter-এর <code>compute()</code>) এ পাস করা ফাংশনগুলো অবশ্যই <strong>টপ-লেভেল বা স্ট্যাটিক</strong> হতে হবে।</li>
<li>আইসোলেট <strong>শুধুমাত্র সত্যিকারের ভারী কাজের জন্য ব্যবহার করুন</strong>; অন্যথায়, ওভারহেড (স্পনিং খরচ, মেসেজ পাসিং) সুবিধার চেয়ে বেশি হতে পারে।</li>
</ul>
</li>
</ul>
<p>পরীক্ষা শুরু করুন! আপনার Dart প্রকল্পগুলোতে I/O-বাউন্ড এবং CPU-বাউন্ড বাধাগুলো চিহ্নিত করুন এবং দেখুন এই সরঞ্জামগুলো কীভাবে পার্থক্য তৈরি করতে পারে। হ্যাপি কোডিং!</p>

</body>
</html>
